===========
Problem
===========
Whenever you expose a web service / api endpoint, you need to implement a rate
limiter to prevent abuse of the service (DOS attacks).

Implement a RateLimiter Class with an isAllow method. Every request comes in with
a unique clientID, deny a request if that client has made more than 100
requests in the past second.


=================================
Questions to ask
=================================
Q: does all the requests have a unique id? 
A: Yes

Q: can time change ?
A: yes, like 100 in last 1 min or x mins. 

Q: does the response delays or abort the request?
A: Abort

===========
Solution 1
===========
-  we create a class called CustomKey. CustomKey class will have 2 attributes, 
time in secs and the client ID. One could get time in secs by taking System.
currentTimeMillis / 1000. Since client ID is unique, a combination of clientID
and time in secs will be unique as well.

-  Create a Hashtable of CustomKey and Integer like Hashtable<CustomKey, Integer>.
The Integer value stores # of requests the client has done in a sec.

-  Every time a client request comes in, check to find out if the key (i.e. 
combination of clientID + sec) is present, if it is present check # of requests
and if the # of requests is more than a 100, isAllow() returns false. If the # of
requests is not 100, increment the # of requests (as the value) and return true
from iaAllow().

-  The Hashtable is used since it is thread safe.

-  Hashtable in this impl can become large. We can put a scheme of "prunning"
in which we prune/remove the "client ID + previous second" key combination, as
we insert for "clientID + current second" key combination.


===========
Solution 2
===========
use redis for the implement.
The redis document shows a simple rete limiter with EXPIRE(ttl) and INCR: https://redis.io/commands/incr
In this question, you should use clientID + unix timestamp as a redis key, and use INCR as a counter.

===========
Solution 3
===========
-  store clientIds in database for each client.
-  Considering AOP (aspect-oriented programming) technique provided by Spring framework.
-  Create custom annotation which will indicate that rate limit is applicable for
the method. You can specify different strategies(requestPerSecondLimit, requestPerHourLimit,
requestPerDayLimit etc) as value to the annotation. e.g.
@ApplyRateLimit(value = "requestPerHourLimit")
-  As part of strategy, we need to provide the concrete implementation
(requestPerHourLimit, requestPerDayLimit)
-  In the implementation, get clientId from a request, check count for clientId
from redis if it is below specified limit then increment the count in redis against
clientId and if it had reached limit then discard/ suitable action based on one's usecase.
-  In order to reset the clinetId request count, AOP schedule the task as specified
in SO(https://stackoverflow.com/questions/16876117/pointcut-for-methods-with-scheduled-spring-annotation)
redis provides API for the same.
